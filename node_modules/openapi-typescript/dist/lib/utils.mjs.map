{"version":3,"file":"utils.mjs","sources":["../../src/lib/utils.ts"],"sourcesContent":["import { escapePointer, parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport c from \"ansi-colors\";\nimport supportsColor from \"supports-color\";\nimport ts from \"typescript\";\nimport type { DiscriminatorObject, OpenAPI3, OpenAPITSOptions, ReferenceObject, SchemaObject } from \"../types.js\";\nimport { tsLiteral, tsModifiers, tsPropertyIndex } from \"./ts.js\";\n\nif (!supportsColor.stdout || supportsColor.stdout.hasBasic === false) {\n  c.enabled = false;\n}\n\nconst DEBUG_GROUPS: Record<string, c.StyleFunction | undefined> = {\n  redoc: c.cyanBright,\n  lint: c.yellowBright,\n  bundle: c.magentaBright,\n  ts: c.blueBright,\n};\n\nexport { c };\n\n/** Given a discriminator object, get the property name */\nexport function createDiscriminatorProperty(\n  discriminator: DiscriminatorObject,\n  { path, readonly = false }: { path: string; readonly?: boolean },\n): ts.TypeElement {\n  // get the inferred propertyName value from the last section of the path (as the spec suggests to do)\n  let value = parseRef(path).pointer.pop();\n  // if mapping, and there’s a match, use this rather than the inferred name\n  if (discriminator.mapping) {\n    // Mapping value can either be a fully-qualified ref (#/components/schemas/XYZ) or a schema name (XYZ)\n    const matchedValue = Object.entries(discriminator.mapping).find(\n      ([, v]) => (!v.startsWith(\"#\") && v === value) || (v.startsWith(\"#\") && parseRef(v).pointer.pop() === value),\n    );\n    if (matchedValue) {\n      value = matchedValue[0]; // why was this designed backwards!?\n    }\n  }\n  return ts.factory.createPropertySignature(\n    /* modifiers     */ tsModifiers({\n      readonly,\n    }),\n    /* name          */ tsPropertyIndex(discriminator.propertyName),\n    /* questionToken */ undefined,\n    /* type          */ tsLiteral(value),\n  );\n}\n\n/** Create a $ref pointer (even from other $refs) */\nexport function createRef(parts: (number | string | undefined | null)[]): string {\n  let pointer = \"#\";\n  for (const part of parts) {\n    if (part === undefined || part === null || part === \"\") {\n      continue;\n    }\n    const maybeRef = parseRef(String(part)).pointer;\n    if (maybeRef.length) {\n      for (const refPart of maybeRef) {\n        pointer += `/${escapePointer(refPart)}`;\n      }\n    } else {\n      pointer += `/${escapePointer(part)}`;\n    }\n  }\n  return pointer;\n}\n\n/** Print debug message (cribbed from the `debug` package, but without all the bells & whistles */\nexport function debug(msg: string, group?: string, time?: number) {\n  if (\n    process.env.DEBUG &&\n    (!group ||\n      process.env.DEBUG === \"*\" ||\n      process.env.DEBUG === \"openapi-ts:*\" ||\n      process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)\n  ) {\n    const groupColor = (group && DEBUG_GROUPS[group]) || c.whiteBright;\n    const groupName = groupColor(`openapi-ts:${group ?? \"info\"}`);\n    let timeFormatted = \"\";\n    if (typeof time === \"number\") {\n      timeFormatted = c.green(` ${formatTime(time)} `);\n    }\n    console.debug(`  ${c.bold(groupName)}${timeFormatted}${msg}`);\n  }\n}\n\n/** Print error message */\nexport function error(msg: string) {\n  console.error(c.red(` ✘  ${msg}`));\n}\n\n/** Format a performance log in a friendly format */\nexport function formatTime(t: number) {\n  if (typeof t === \"number\") {\n    if (t < 1000) {\n      return `${Math.round(10 * t) / 10}ms`;\n    }\n    if (t < 60000) {\n      return `${Math.round(t / 100) / 10}s`;\n    }\n    return `${Math.round(t / 6000) / 10}m`;\n  }\n  return t;\n}\n\n/** Call Object.entries() and optionally sort */\nexport function getEntries<T>(\n  obj: ArrayLike<T> | Record<string, T>,\n  options?: {\n    alphabetize?: boolean;\n    excludeDeprecated?: boolean;\n  },\n) {\n  let entries = Object.entries(obj);\n  if (options?.alphabetize) {\n    entries.sort(([a], [b]) => a.localeCompare(b, \"en-us\", { numeric: true }));\n  }\n  if (options?.excludeDeprecated) {\n    entries = entries.filter(([, v]) => !(v && typeof v === \"object\" && \"deprecated\" in v && v.deprecated));\n  }\n  return entries;\n}\n\n/** resolve a $ref in a schema */\nexport function resolveRef<T>(\n  schema: any,\n  $ref: string,\n  { silent = false, visited = [] }: { silent: boolean; visited?: string[] },\n): T | undefined {\n  const { pointer } = parseRef($ref);\n  if (!pointer.length) {\n    return undefined;\n  }\n  let node = schema;\n  for (const key of pointer) {\n    if (node && typeof node === \"object\" && node[key]) {\n      node = node[key];\n    } else {\n      warn(`Could not resolve $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n  }\n\n  // if this is also a $ref, keep tracing\n  if (node && typeof node === \"object\" && node.$ref) {\n    if (visited.includes(node.$ref)) {\n      warn(`Could not resolve circular $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n    return resolveRef(schema, node.$ref, {\n      silent,\n      visited: [...visited, node.$ref],\n    });\n  }\n\n  return node;\n}\n\nfunction createDiscriminatorEnum(values: string[], prevSchema?: SchemaObject): SchemaObject {\n  return {\n    type: \"string\",\n    enum: values,\n    description: prevSchema?.description\n      ? `${prevSchema.description} (enum property replaced by openapi-typescript)`\n      : \"discriminator enum property added by openapi-typescript\",\n  };\n}\n\n/** Adds or replaces the discriminator enum with the passed `values` in a schema defined by `ref` */\nfunction patchDiscriminatorEnum(\n  schema: SchemaObject,\n  ref: string,\n  values: string[],\n  discriminator: DiscriminatorObject,\n  discriminatorRef: string,\n  options: OpenAPITSOptions,\n): boolean {\n  const resolvedSchema = resolveRef<SchemaObject>(schema, ref, {\n    silent: options.silent ?? false,\n  });\n\n  if (resolvedSchema?.allOf) {\n    // if the schema is an allOf, we can append a new schema object to the allOf array\n    resolvedSchema.allOf.push({\n      type: \"object\",\n      // discriminator enum properties always need to be required\n      required: [discriminator.propertyName],\n      properties: {\n        [discriminator.propertyName]: createDiscriminatorEnum(values),\n      },\n    });\n\n    return true;\n  } else if (typeof resolvedSchema === \"object\" && \"type\" in resolvedSchema && resolvedSchema.type === \"object\") {\n    // if the schema is an object, we can apply the discriminator enums to its properties\n    if (!resolvedSchema.properties) {\n      resolvedSchema.properties = {};\n    }\n\n    // discriminator enum properties always need to be required\n    if (!resolvedSchema.required) {\n      resolvedSchema.required = [discriminator.propertyName];\n    } else if (!resolvedSchema.required.includes(discriminator.propertyName)) {\n      resolvedSchema.required.push(discriminator.propertyName);\n    }\n\n    // add/replace the discriminator enum property\n    resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(\n      values,\n      resolvedSchema.properties[discriminator.propertyName] as SchemaObject,\n    );\n\n    return true;\n  }\n\n  warn(\n    `Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(\n      \", \",\n    )} (Discriminator: ${discriminatorRef})`,\n    options.silent,\n  );\n\n  return false;\n}\n\ntype InternalDiscriminatorMapping = Record<string, { inferred?: string; defined?: string[] }>;\n\n/** Return a key–value map of discriminator objects found in a schema */\nexport function scanDiscriminators(schema: OpenAPI3, options: OpenAPITSOptions) {\n  // all discriminator objects found in the schema\n  const objects: Record<string, DiscriminatorObject> = {};\n\n  // refs of all mapped schema objects we have successfully handled to infer the discriminator enum value\n  const refsHandled: string[] = [];\n\n  // perform 2 passes: first, collect all discriminator definitions and handle oneOf and mappings\n  walk(schema, (obj, path) => {\n    const discriminator = obj?.discriminator as DiscriminatorObject | undefined;\n    if (!discriminator?.propertyName) {\n      return;\n    }\n\n    // collect discriminator object for later usage\n    const ref = createRef(path);\n\n    objects[ref] = discriminator;\n\n    // if a mapping is available we will help Typescript to infer properties by adding the discriminator enum with its single mapped value to each schema\n    // we only handle the mapping in advance for discriminator + oneOf compositions right now\n    if (!obj?.oneOf || !Array.isArray(obj.oneOf)) {\n      return;\n    }\n\n    const oneOf: (SchemaObject | ReferenceObject)[] = obj.oneOf;\n    const mapping: InternalDiscriminatorMapping = {};\n\n    // the mapping can be inferred from the oneOf refs next to the discriminator object\n    for (const item of oneOf) {\n      if (\"$ref\" in item) {\n        // the name of the schema is the inferred discriminator enum value\n        const value = item.$ref.split(\"/\").pop();\n\n        if (value) {\n          if (!mapping[item.$ref]) {\n            mapping[item.$ref] = { inferred: value };\n          } else {\n            mapping[item.$ref].inferred = value;\n          }\n        }\n      }\n    }\n\n    // the mapping can be defined in the discriminator object itself\n    if (discriminator.mapping) {\n      for (const mappedValue in discriminator.mapping) {\n        const mappedRef = discriminator.mapping[mappedValue];\n        if (!mappedRef) {\n          continue;\n        }\n\n        if (!mapping[mappedRef]?.defined) {\n          // this overrides inferred values, but we don't need them anymore as soon as we have a defined value\n          mapping[mappedRef] = { defined: [] };\n        }\n\n        mapping[mappedRef].defined?.push(mappedValue);\n      }\n    }\n\n    for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {\n      if (refsHandled.includes(mappedRef)) {\n        continue;\n      }\n\n      if (!inferred && !defined) {\n        continue;\n      }\n\n      // prefer defined values over automatically inferred ones\n      // the inferred enum values from the schema might not represent the actual enum values of the discriminator,\n      // so if we have defined values, use them instead\n      // biome-ignore lint/style/noNonNullAssertion: we just checked for this\n      const mappedValues = defined ?? [inferred!];\n\n      if (\n        patchDiscriminatorEnum(schema as unknown as SchemaObject, mappedRef, mappedValues, discriminator, ref, options)\n      ) {\n        refsHandled.push(mappedRef);\n      }\n    }\n  });\n\n  // second, collect the schema objects that inherit from discriminators\n  // (sometimes this mapping is implicit, so it can’t be done until we know\n  // about every discriminator in the document)\n  walk(schema, (obj, path) => {\n    if (!obj || !Array.isArray(obj.allOf)) {\n      return;\n    }\n\n    for (const item of (obj as any).allOf) {\n      if (\"$ref\" in item) {\n        if (!objects[item.$ref]) {\n          return;\n        }\n\n        const ref = createRef(path);\n        const discriminator = objects[item.$ref];\n        const mappedValues: string[] = [];\n\n        if (discriminator.mapping) {\n          for (const mappedValue in discriminator.mapping) {\n            if (discriminator.mapping[mappedValue] === ref) {\n              mappedValues.push(mappedValue);\n            }\n          }\n\n          if (mappedValues.length > 0) {\n            if (\n              patchDiscriminatorEnum(\n                schema as unknown as SchemaObject,\n                ref,\n                mappedValues,\n                discriminator,\n                item.$ref,\n                options,\n              )\n            ) {\n              refsHandled.push(ref);\n            }\n          }\n        }\n\n        objects[ref] = {\n          ...objects[item.$ref],\n        };\n      } else if (item.discriminator?.propertyName) {\n        objects[createRef(path)] = { ...item.discriminator };\n      }\n    }\n  });\n\n  return { objects, refsHandled };\n}\n\n/** Walk through any JSON-serializable (i.e. non-circular) object */\nexport function walk(\n  obj: unknown,\n  cb: (value: Record<string, unknown>, path: (string | number)[]) => void,\n  path: (string | number)[] = [],\n): void {\n  if (!obj || typeof obj !== \"object\") {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      walk(obj[i], cb, path.concat(i));\n    }\n    return;\n  }\n  cb(obj as Record<string, unknown>, path);\n  for (const k of Object.keys(obj)) {\n    walk((obj as Record<string, unknown>)[k], cb, path.concat(k));\n  }\n}\n\n/** Print warning message */\nexport function warn(msg: string, silent = false) {\n  if (!silent) {\n    console.warn(c.yellow(` ⚠  ${msg}`));\n  }\n}\n"],"names":[],"mappings":"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"}