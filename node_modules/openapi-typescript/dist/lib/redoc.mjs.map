{"version":3,"file":"redoc.mjs","sources":["../../src/lib/redoc.ts"],"sourcesContent":["import {\n  BaseResolver,\n  bundle,\n  makeDocumentFromString,\n  type Config as RedoclyConfig,\n  Source,\n  type Document,\n  lintDocument,\n  type NormalizedProblem,\n} from \"@redocly/openapi-core\";\nimport { performance } from \"node:perf_hooks\";\nimport { Readable } from \"node:stream\";\nimport { fileURLToPath } from \"node:url\";\nimport parseJson from \"parse-json\";\nimport type { OpenAPI3 } from \"../types.js\";\nimport { debug, error, warn } from \"./utils.js\";\n\nexport interface ValidateAndBundleOptions {\n  redoc: RedoclyConfig;\n  silent: boolean;\n  cwd?: URL;\n}\n\ninterface ParseSchemaOptions {\n  absoluteRef: string;\n  resolver: BaseResolver;\n}\n\nexport async function parseSchema(schema: unknown, { absoluteRef, resolver }: ParseSchemaOptions): Promise<Document> {\n  if (!schema) {\n    throw new Error(\"Canâ€™t parse empty schema\");\n  }\n  if (schema instanceof URL) {\n    const result = await resolver.resolveDocument(null, absoluteRef, true);\n    if (\"parsed\" in result) {\n      return result;\n    }\n    throw result.originalError;\n  }\n  if (schema instanceof Readable) {\n    const contents = await new Promise<string>((resolve) => {\n      schema.resume();\n      schema.setEncoding(\"utf8\");\n      let content = \"\";\n      schema.on(\"data\", (chunk: string) => {\n        content += chunk;\n      });\n      schema.on(\"end\", () => {\n        resolve(content.trim());\n      });\n    });\n    return parseSchema(contents, { absoluteRef, resolver });\n  }\n  if (schema instanceof Buffer) {\n    return parseSchema(schema.toString(\"utf8\"), { absoluteRef, resolver });\n  }\n  if (typeof schema === \"string\") {\n    // URL\n    if (schema.startsWith(\"http://\") || schema.startsWith(\"https://\") || schema.startsWith(\"file://\")) {\n      const url = new URL(schema);\n      return parseSchema(url, {\n        absoluteRef: url.protocol === \"file:\" ? fileURLToPath(url) : url.href,\n        resolver,\n      });\n    }\n    // JSON\n    if (schema[0] === \"{\") {\n      return {\n        source: new Source(absoluteRef, schema, \"application/json\"),\n        parsed: parseJson(schema),\n      };\n    }\n    // YAML\n    return makeDocumentFromString(schema, absoluteRef);\n  }\n  if (typeof schema === \"object\" && !Array.isArray(schema)) {\n    return {\n      source: new Source(absoluteRef, JSON.stringify(schema), \"application/json\"),\n      parsed: schema,\n    };\n  }\n  throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? \"Array\" : typeof schema}`);\n}\n\nfunction _processProblems(problems: NormalizedProblem[], options: { silent: boolean }) {\n  if (problems.length) {\n    let errorMessage: string | undefined = undefined;\n    for (const problem of problems) {\n      const problemLocation = problem.location?.[0].pointer;\n      const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;\n      if (problem.severity === \"error\") {\n        errorMessage = problemMessage;\n        error(problemMessage);\n      } else {\n        warn(problemMessage, options.silent);\n      }\n    }\n    if (errorMessage) {\n      throw new Error(errorMessage);\n    }\n  }\n}\n\n/**\n * Validate an OpenAPI schema and flatten into a single schema using Redocly CLI\n */\nexport async function validateAndBundle(\n  source: string | URL | OpenAPI3 | Readable | Buffer,\n  options: ValidateAndBundleOptions,\n) {\n  const redocConfigT = performance.now();\n  debug(\"Loaded Redoc config\", \"redoc\", performance.now() - redocConfigT);\n  const redocParseT = performance.now();\n  let absoluteRef = fileURLToPath(new URL(options?.cwd ?? `file://${process.cwd()}/`));\n  if (source instanceof URL) {\n    absoluteRef = source.protocol === \"file:\" ? fileURLToPath(source) : source.href;\n  }\n  const resolver = new BaseResolver(options.redoc.resolve);\n  const document = await parseSchema(source, {\n    absoluteRef,\n    resolver,\n  });\n  debug(\"Parsed schema\", \"redoc\", performance.now() - redocParseT);\n\n  // 1. check for OpenAPI 3 or greater\n  const openapiVersion = Number.parseFloat(document.parsed.openapi);\n  if (\n    document.parsed.swagger ||\n    !document.parsed.openapi ||\n    Number.isNaN(openapiVersion) ||\n    openapiVersion < 3 ||\n    openapiVersion >= 4\n  ) {\n    if (document.parsed.swagger) {\n      throw new Error(\"Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.\");\n    }\n    if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {\n      throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);\n    }\n    throw new Error(\"Unsupported schema format, expected `openapi: 3.x`\");\n  }\n\n  // 2. lint\n  const redocLintT = performance.now();\n  const problems = await lintDocument({\n    document,\n    config: options.redoc.styleguide,\n    externalRefResolver: resolver,\n  });\n  _processProblems(problems, options);\n  debug(\"Linted schema\", \"lint\", performance.now() - redocLintT);\n\n  // 3. bundle\n  const redocBundleT = performance.now();\n  const bundled = await bundle({\n    config: options.redoc,\n    dereference: false,\n    doc: document,\n  });\n  _processProblems(bundled.problems, options);\n  debug(\"Bundled schema\", \"bundle\", performance.now() - redocBundleT);\n\n  return bundled.bundle.parsed;\n}\n"],"names":[],"mappings":"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"}