{"version":3,"file":"ts.mjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport type { Referenced, OasRef } from \"@redocly/openapi-core\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    let text =\n      output.length === 1\n        ? `* ${output.join(\"\\n\")} `\n        : `*\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  if (metadata.description === undefined) {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(\n    member,\n    ts.SyntaxKind.SingleLineCommentTrivia,\n    \" \".concat(metadata.description.trim()),\n    true,\n  );\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: {\n  readonly?: boolean;\n  export?: boolean;\n}): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":[],"mappings":";;;AAKO,MAAM,oBAAuB,GAAA;AAC7B,MAAM,wBAA2B,GAAA;AACjC,MAAM,kCAAqC,GAAA;AAC3C,MAAM,qBAAgD,GAAA;AAAA,EAC3D,GAAK,EAAA;AAAA;AAEP;AAEO,MAAM,UAAU,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,cAAc;AAC7E,MAAM,QAAQ,EAAG,CAAA,OAAA,CAAQ,sBAAsB,EAAG,CAAA,OAAA,CAAQ,aAAa;AACvE,MAAM,QAAQ,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,YAAY;AACzE,MAAM,OAAO,EAAG,CAAA,OAAA,CAAQ,sBAAsB,EAAG,CAAA,OAAA,CAAQ,YAAY;AACrE,MAAM,SAAS,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,aAAa;AAC3E,MAAM,iBAAiB,EAAG,CAAA,OAAA,CAAQ,WAAY,CAAA,EAAA,CAAG,WAAW,aAAa;AACzE,MAAM,SAAS,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,aAAa;AAC3E,MAAM,OAAO,EAAG,CAAA,OAAA,CAAQ,sBAAsB,EAAG,CAAA,OAAA,CAAQ,YAAY;AACrE,MAAM,YAAY,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,gBAAgB;AACjF,MAAM,UAAU,EAAG,CAAA,OAAA,CAAQ,qBAAsB,CAAA,EAAA,CAAG,WAAW,cAAc;AAEpF,MAAM,KAAQ,GAAA,QAAA;AACd,MAAM,UAAa,GAAA,OAAA;AAqBH,SAAA,eAAA,CAAgB,cAAqC,IAAkC,EAAA;AACrG,EAAI,IAAA,CAAC,gBAAgB,OAAO,YAAA,KAAiB,YAAY,KAAM,CAAA,OAAA,CAAQ,YAAY,CAAG,EAAA;AACpF,IAAA;AAAA;AAEF,EAAA,MAAM,SAAmB,EAAC;AAG1B,EAAA,IAAI,aAAa,KAAO,EAAA;AACtB,IAAA,MAAA,CAAO,KAAK,YAAa,CAAA,KAAA,CAAM,OAAQ,CAAA,KAAA,EAAO,WAAW,CAAC,CAAA;AAAA;AAE5D,EAAA,IAAI,aAAa,OAAS,EAAA;AACxB,IAAA,MAAA,CAAO,KAAK,YAAa,CAAA,OAAA,CAAQ,OAAQ,CAAA,KAAA,EAAO,WAAW,CAAC,CAAA;AAAA;AAE9D,EAAA,IAAI,aAAa,MAAQ,EAAA;AACvB,IAAA,MAAA,CAAO,IAAK,CAAA,CAAA,QAAA,EAAW,YAAa,CAAA,MAAM,CAAE,CAAA,CAAA;AAAA;AAK9C,EAAA,IAAI,aAAa,UAAY,EAAA;AAC3B,IAAA,MAAA,CAAO,KAAK,aAAa,CAAA;AAAA;AAI3B,EAAA,MAAM,kBAAqB,GAAA,CAAC,aAAe,EAAA,SAAA,EAAW,SAAS,CAAA;AAC/D,EAAA,KAAA,MAAW,SAAS,kBAAoB,EAAA;AACtC,IAAM,MAAA,gBAAA,GAAmB,KAAU,KAAA,SAAA,IAAa,KAAU,KAAA,SAAA;AAC1D,IAAI,IAAA,YAAA,CAAa,KAAK,CAAA,KAAM,MAAW,EAAA;AACrC,MAAA;AAAA;AAEF,IAAA,IAAI,YAAa,CAAA,KAAK,CAAM,KAAA,EAAA,IAAM,CAAC,gBAAkB,EAAA;AACnD,MAAA;AAAA;AAEF,IAAA,MAAM,UACJ,GAAA,OAAO,YAAa,CAAA,KAAK,MAAM,QAAW,GAAA,IAAA,CAAK,SAAU,CAAA,YAAA,CAAa,KAAK,CAAG,EAAA,IAAA,EAAM,CAAC,CAAA,GAAI,aAAa,KAAK,CAAA;AAC7G,IAAO,MAAA,CAAA,IAAA,CAAK,CAAI,CAAA,EAAA,KAAK,CAAI,CAAA,EAAA,MAAA,CAAO,UAAU,CAAA,CAAE,OAAQ,CAAA,KAAA,EAAO,WAAW,CAAC,CAAE,CAAA,CAAA;AAAA;AAI3E,EAAA,IAAI,WAAW,YAAc,EAAA;AAC3B,IAAA,MAAA,CAAO,KAAK,WAAW,CAAA;AAAA;AAIzB,EAAA,IAAI,aAAa,IAAM,EAAA;AACrB,IAAA,IAAI,IAAO,GAAA,SAAA;AACX,IAAA,IAAI,KAAM,CAAA,OAAA,CAAQ,YAAa,CAAA,IAAI,CAAG,EAAA;AACpC,MAAO,IAAA,GAAA,YAAA,CAAa,IAAK,CAAA,IAAA,CAAK,GAAG,CAAA;AAAA,KACxB,MAAA,IAAA,OAAO,YAAa,CAAA,IAAA,KAAS,QAAU,EAAA;AAChD,MAAA,IAAA,GAAO,YAAa,CAAA,IAAA;AAAA;AAEtB,IAAO,MAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,EAAG,aAAa,QAAW,GAAA,OAAA,GAAU,EAAE,CAAG,CAAA,CAAA,CAAA;AAAA;AAKtE,EAAA,IAAI,OAAO,MAAQ,EAAA;AACjB,IAAI,IAAA,IAAA,GACF,OAAO,MAAW,KAAA,CAAA,GACd,KAAK,MAAO,CAAA,IAAA,CAAK,IAAI,CAAC,CACtB,CAAA,CAAA,GAAA,CAAA;AAAA,GACL,EAAA,MAAA,CAAO,IAAK,CAAA,OAAO,CAAC;AAAA,CAAA,CAAA;AACrB,IAAO,IAAA,GAAA,IAAA,CAAK,OAAQ,CAAA,UAAA,EAAY,MAAM,CAAA;AAEtC,IAAG,EAAA,CAAA,0BAAA;AAAA;AAAA,MACwB,IAAA;AAAA;AAAA,MACA,GAAG,UAAW,CAAA,sBAAA;AAAA;AAAA;AAAA,MACd,IAAA;AAAA;AAAA,MACA;AAAA,KAC3B;AAAA;AAEJ;AAEA,SAAS,SAAY,GAAmC,EAAA;AACtD,EAAO,OAAA,OAAA,CAAS,IAAe,IAAI,CAAA;AACrC;AAGA,SAAS,kBAAkB,GAA0D,EAAA;AACnF,EAAA,OAAO,QAAQ,GAAO,IAAA,CAAC,SAAS,GAAG,CAAA,IAAK,IAAI,EAAE,CAAA;AAChD;AAEA,SAAS,gBAAA,CAAiB,SAA0D,QAA6B,EAAA;AAC/G,EAAA,OAAO,QAAS,CAAA,MAAA,CAAO,CAAC,GAAA,EAAK,OAAY,KAAA;AACvC,IAAA,OAAO,GAAG,OAAQ,CAAA,2BAAA;AAAA,MAChB,GAAA;AAAA,MACA,GAAG,OAAQ,CAAA,qBAAA;AAAA,QACT,OAAO,OAAY,KAAA,QAAA,GACf,EAAG,CAAA,OAAA,CAAQ,oBAAqB,CAAA,OAAO,CACvC,GAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,OAAO;AAAA;AAC5C,KACF;AAAA,KACC,IAAI,CAAA;AACT;AAmBgB,SAAA,OAAA,CAAQ,MAAc,QAAyC,EAAA;AAC7E,EAAA,MAAM,EAAE,OAAA,EAAY,GAAA,QAAA,CAAS,IAAI,CAAA;AACjC,EAAI,IAAA,OAAA,CAAQ,WAAW,CAAG,EAAA;AACxB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAuB,oBAAA,EAAA,IAAI,CAAyB,uBAAA,CAAA,CAAA;AAAA;AAGtE,EAAM,MAAA,gBAAA,GAAmB,kBAAkB,QAAQ,CAAA;AAInD,EAAM,MAAA,cAAA,GAAiB,QAAQ,CAAC,CAAA;AAChC,EAAA,MAAM,eAAkB,GAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,EAAG,CAAC,CAAA;AAC1C,EAAM,MAAA,YAAA,GAAe,OAAQ,CAAA,KAAA,CAAM,CAAC,CAAA;AAEpC,EAAA,MAAM,WAAc,GAAA,gBAAA;AAAA,IAClB,EAAA,CAAG,QAAQ,uBAAwB,CAAA,EAAA,CAAG,QAAQ,gBAAiB,CAAA,MAAA,CAAO,cAAc,CAAC,CAAC,CAAA;AAAA,IACtF,GAAG;AAAA,GACL;AAEA,EAAA,OAAO,aAAa,MAAwD,CAAA,CAAC,GAAK,EAAA,OAAA,EAAS,OAAO,QAAa,KAAA;AAG7G,IAAA,IAAI,YAAY,YAAc,EAAA;AAC5B,MAAO,OAAA,GAAA;AAAA;AAGT,IAAA,IAAI,gBAAoB,IAAA,KAAA,KAAU,QAAS,CAAA,MAAA,GAAS,CAAG,EAAA;AACrD,MAAA,OAAO,gBAAiB,CAAA,GAAA,EAAK,QAAS,CAAA,EAAA,EAAI,SAAS,IAAI,CAAA;AAAA;AAGzD,IAAO,OAAA,gBAAA,CAAiB,KAAK,OAAO,CAAA;AAAA,KACnC,WAAW,CAAA;AAChB;AASgB,SAAA,WAAA,CACd,KACA,OACQ,EAAA;AACR,EAAA,MAAM,aAAa,EAAG,CAAA,gBAAA;AAAA,IACpB,SAAS,QAAY,IAAA,eAAA;AAAA,IACrB,SAAS,UAAc,IAAA,EAAA;AAAA,IACvB,GAAG,YAAa,CAAA,MAAA;AAAA,IAChB,KAAA;AAAA,IACA,GAAG,UAAW,CAAA;AAAA,GAChB;AAGA,EAAW,UAAA,CAAA,UAAA,GAAa,EAAG,CAAA,OAAA,CAAQ,eAAgB,CAAA,KAAA,CAAM,OAAQ,CAAA,GAAG,CAAI,GAAA,GAAA,GAAM,CAAC,GAAG,CAAC,CAAA;AAEnF,EAAM,MAAA,OAAA,GAAU,GAAG,aAAc,CAAA;AAAA,IAC/B,OAAA,EAAS,GAAG,WAAY,CAAA,QAAA;AAAA,IACxB,cAAgB,EAAA,KAAA;AAAA,IAChB,GAAG,OAAS,EAAA;AAAA,GACb,CAAA;AACD,EAAO,OAAA,OAAA,CAAQ,UAAU,UAAU,CAAA;AACrC;AAGO,SAAS,YAAY,MAA2B,EAAA;AACrD,EAAA,OAAO,EAAG,CAAA,gBAAA;AAAA;AAAA,IACc,aAAA;AAAA;AAAA,IACA,MAAA;AAAA;AAAA,IACA,GAAG,YAAa,CAAA,MAAA;AAAA;AAAA,IAChB,MAAA;AAAA;AAAA,IACA;AAAA,GACtB,CAAA,UAAA;AACJ;AAMO,SAAS,SAAS,KAAqC,EAAA;AAC5D,EAAM,MAAA,gBAAA,uBAAuB,GAAY,EAAA;AACzC,EAAA,MAAM,gBAA+B,EAAC;AACtC,EAAA,KAAA,MAAW,KAAK,KAAO,EAAA;AAErB,IAAA,IAAI,EAAE,MAAA,KAAY,CAAsB,CAAA,OAAA,IAAW,CAAK,CAAA,CAAA,EAAA;AACtD,MAAA,MAAM,EAAE,IAAA,EAAU,GAAA,CAAA,CAAsB,OAAW,IAAA,CAAA;AACnD,MAAI,IAAA,gBAAA,CAAiB,GAAI,CAAA,IAAI,CAAG,EAAA;AAC9B,QAAA;AAAA;AAEF,MAAI,IAAA,aAAA,CAAc,CAAC,CAAG,EAAA;AACpB,QAAA,gBAAA,CAAiB,IAAI,IAAI,CAAA;AAAA;AAC3B;AAEF,IAAA,aAAA,CAAc,KAAK,CAAC,CAAA;AAAA;AAEtB,EAAO,OAAA,aAAA;AACT;AAEa,MAAA,SAAA,uBAAgB,GAAgC;AAGtD,SAAS,MACd,CAAA,IAAA,EACA,OACA,EAAA,QAAA,EACA,OACA,EAAA;AACA,EAAI,IAAA,QAAA,GAAW,mBAAmB,IAAI,CAAA;AACtC,EAAW,QAAA,GAAA,CAAA,EAAG,QAAS,CAAA,CAAC,CAAE,CAAA,WAAA,EAAa,CAAG,EAAA,QAAA,CAAS,SAAU,CAAA,CAAC,CAAC,CAAA,CAAA;AAC/D,EAAA,IAAI,GAAM,GAAA,EAAA;AACV,EAAA,IAAI,SAAS,WAAa,EAAA;AACxB,IAAM,GAAA,GAAA,CAAA,EAAG,OACN,CAAA,KAAA,CAAM,CAAC,CAAA,CACP,MACA,CAAA,GAAA,CAAI,CAAC,CAAA,EAAG,CAAM,KAAA;AACb,MAAA,OAAO,CAAG,EAAA,QAAA,GAAW,CAAC,CAAA,EAAG,IAAQ,IAAA,MAAA,CAAO,CAAC,CAAC,CAAI,CAAA,EAAA,QAAA,GAAW,CAAC,CAAA,EAAG,eAAe,EAAE,CAAA,CAAA;AAAA,KAC/E,CAAA,CACA,IAAK,CAAA,GAAG,CAAC,CAAA,CAAA;AACZ,IAAI,IAAA,SAAA,CAAU,GAAI,CAAA,GAAG,CAAG,EAAA;AACtB,MAAO,OAAA,SAAA,CAAU,IAAI,GAAG,CAAA;AAAA;AAC1B;AAEF,EAAM,MAAA,eAAA,GAAkB,GAAG,OAAQ,CAAA,qBAAA;AAAA;AAAA,IACjB,OAAA,GAAU,YAAY,EAAE,MAAA,EAAQ,QAAQ,MAAU,IAAA,KAAA,EAAO,CAAI,GAAA,MAAA;AAAA;AAAA,IAC7D,QAAA;AAAA;AAAA,IACA,OAAA,CAAQ,GAAI,CAAA,CAAC,KAAO,EAAA,CAAA,KAAM,aAAa,KAAO,EAAA,QAAA,GAAW,CAAC,CAAC,CAAC;AAAA,GAC9E;AACA,EAAA,OAAA,EAAS,WAAe,IAAA,SAAA,CAAU,GAAI,CAAA,GAAA,EAAK,eAAe,CAAA;AAC1D,EAAO,OAAA,eAAA;AACT;AAGO,SAAS,wBACd,CAAA,IAAA,EACA,WACA,EAAA,MAAA,EACA,OACA,EAAA;AACA,EAAI,IAAA,YAAA,GAAe,mBAAmB,IAAI,CAAA;AAC1C,EAAe,YAAA,GAAA,CAAA,EAAG,YAAa,CAAA,CAAC,CAAE,CAAA,WAAA,EAAa,CAAG,EAAA,YAAA,CAAa,SAAU,CAAA,CAAC,CAAC,CAAA,CAAA;AAE3E,EAAM,MAAA,SAAA,GAAY,OAAS,EAAA,QAAA,GACvB,eAAgB,CAAA,WAAA,EAAa,OAAQ,CAAA,YAAY,CACjD,GAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,WAAW,CAAA;AAE9C,EAAA,OAAO,GAAG,OAAQ,CAAA,uBAAA;AAAA,IAChB,OAAA,GAAU,YAAY,EAAE,MAAA,EAAQ,QAAQ,MAAU,IAAA,KAAA,EAAO,CAAI,GAAA,MAAA;AAAA,IAC7D,GAAG,OAAQ,CAAA,6BAAA;AAAA,MACT;AAAA,QACE,GAAG,OAAQ,CAAA,yBAAA;AAAA,UACT,YAAA;AAAA,UACA,MAAA;AAAA,UACA,SAAA;AAAA,UACA,GAAG,OAAQ,CAAA,4BAAA;AAAA,YACT,MAAA,CAAO,GAAI,CAAA,CAAC,KAAU,KAAA;AACpB,cAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,gBAAA,IAAI,QAAQ,CAAG,EAAA;AACb,kBAAA,OAAO,GAAG,OAAQ,CAAA,2BAAA;AAAA,oBAChB,GAAG,UAAW,CAAA,UAAA;AAAA,oBACd,GAAG,OAAQ,CAAA,oBAAA,CAAqB,IAAK,CAAA,GAAA,CAAI,KAAK,CAAC;AAAA,mBACjD;AAAA,iBACK,MAAA;AACL,kBAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,oBAAA,CAAqB,KAAK,CAAA;AAAA;AAC9C,eACK,MAAA;AACL,gBAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,KAAK,CAAA;AAAA;AAC7C,aACD;AAAA;AACH;AACF,OACF;AAAA,MACA,GAAG,SAAU,CAAA;AAAA;AACf,GACF;AACF;AAEA,SAAS,mBAAmB,IAAc,EAAA;AACxC,EAAA,IAAI,aAAgB,GAAA,IAAA,CAAK,OAAQ,CAAA,wBAAA,EAA0B,CAAC,CAAM,KAAA;AAChE,IAAA,MAAM,IAAO,GAAA,CAAA,CAAE,CAAE,CAAA,MAAA,GAAS,CAAC,CAAA;AAC3B,IAAA,OAAO,mCAAmC,IAAK,CAAA,IAAI,CAAI,GAAA,EAAA,GAAK,KAAK,WAAY,EAAA;AAAA,GAC9E,CAAA;AACD,EAAA,IAAI,MAAO,CAAA,IAAA,CAAK,CAAC,CAAC,KAAK,CAAG,EAAA;AACxB,IAAA,aAAA,GAAgB,QAAQ,IAAI,CAAA,CAAA;AAAA;AAE9B,EAAO,OAAA,aAAA;AACT;AAGO,SAAS,YAAa,CAAA,KAAA,EAAwB,QAAoD,GAAA,EAAI,EAAA;AAC3G,EAAA,IAAI,IAAO,GAAA,QAAA,CAAS,IAAQ,IAAA,MAAA,CAAO,KAAK,CAAA;AACxC,EAAA,IAAI,CAAC,oBAAA,CAAqB,IAAK,CAAA,IAAI,CAAG,EAAA;AACpC,IAAA,IAAI,MAAO,CAAA,IAAA,CAAK,CAAC,CAAC,KAAK,CAAG,EAAA;AACxB,MAAA,IAAA,GAAO,CAAQ,KAAA,EAAA,IAAI,CAAG,CAAA,CAAA,OAAA,CAAQ,KAAK,GAAG,CAAA;AAAA,KAC7B,MAAA,IAAA,IAAA,CAAK,CAAC,CAAA,KAAM,GAAK,EAAA;AAC1B,MAAA,IAAA,GAAO,CAAa,UAAA,EAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA;AAGnC,IAAM,MAAA,gBAAA,GAAmB,IAAK,CAAA,KAAA,CAAM,kCAAkC,CAAA;AACtE,IAAA,IAAI,gBAAkB,EAAA;AACpB,MAAI,IAAA,gBAAA,CAAiB,CAAC,CAAA,KAAM,IAAM,EAAA;AAChC,QAAA,IAAA,GAAO,IAAI,IAAI,CAAA,CAAA,CAAA;AAAA,OACV,MAAA;AACL,QAAA,IAAA,GAAO,IAAK,CAAA,OAAA,CAAQ,kCAAoC,EAAA,CAAC,CAAM,KAAA;AAC7D,UAAA,OAAO,CAAK,IAAA,qBAAA,GAAwB,qBAAsB,CAAA,CAAC,CAAI,GAAA,GAAA;AAAA,SAChE,CAAA;AAAA;AACH;AACF;AAGF,EAAI,IAAA,MAAA;AACJ,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAA,MAAM,OACJ,GAAA,KAAA,GAAQ,CACJ,GAAA,EAAA,CAAG,OAAQ,CAAA,2BAAA;AAAA,MACT,GAAG,UAAW,CAAA,UAAA;AAAA,MACd,GAAG,OAAQ,CAAA,oBAAA,CAAqB,IAAK,CAAA,GAAA,CAAI,KAAK,CAAC;AAAA,KAEjD,GAAA,EAAA,CAAG,OAAQ,CAAA,oBAAA,CAAqB,KAAK,CAAA;AAE3C,IAAA,MAAA,GAAS,EAAG,CAAA,OAAA,CAAQ,gBAAiB,CAAA,IAAA,EAAM,OAAO,CAAA;AAAA,GAC7C,MAAA;AACL,IAAS,MAAA,GAAA,EAAA,CAAG,QAAQ,gBAAiB,CAAA,IAAA,EAAM,GAAG,OAAQ,CAAA,mBAAA,CAAoB,KAAK,CAAC,CAAA;AAAA;AAGlF,EAAI,IAAA,QAAA,CAAS,gBAAgB,MAAW,EAAA;AACtC,IAAO,OAAA,MAAA;AAAA;AAGT,EAAA,OAAO,EAAG,CAAA,0BAAA;AAAA,IACR,MAAA;AAAA,IACA,GAAG,UAAW,CAAA,uBAAA;AAAA,IACd,GAAI,CAAA,MAAA,CAAO,QAAS,CAAA,WAAA,CAAY,MAAM,CAAA;AAAA,IACtC;AAAA,GACF;AACF;AAGO,SAAS,eAAe,KAAmC,EAAA;AAChE,EAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,IAAO,OAAA,KAAA;AAAA;AAET,EAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,IAAA,OAAO,MAAM,CAAC,CAAA;AAAA;AAEhB,EAAA,OAAO,EAAG,CAAA,OAAA,CAAQ,0BAA2B,CAAA,QAAA,CAAS,KAAK,CAAC,CAAA;AAC9D;AAGO,SAAS,cAAc,IAA4B,EAAA;AACxD,EAAA,IAAI,CAAC,IAAM,EAAA;AACT,IAAO,OAAA,IAAA;AAAA;AAET,EAAA,OACE,GAAG,UAAW,CAAA,IAAA,CAAK,IAAI,CAAM,KAAA,gBAAA,IAC7B,GAAG,UAAW,CAAA,IAAA,CAAK,IAAI,CAAA,KAAM,kBAC7B,EAAG,CAAA,UAAA,CAAW,KAAK,IAAI,CAAA,KAAM,iBAC7B,EAAG,CAAA,UAAA,CAAW,IAAK,CAAA,IAAI,MAAM,eAC7B,IAAA,EAAA,CAAG,WAAW,IAAK,CAAA,IAAI,MAAM,eAC7B,IAAA,EAAA,CAAG,UAAW,CAAA,IAAA,CAAK,IAAI,CAAM,KAAA,kBAAA,IAC5B,aAAa,IAAQ,IAAA,aAAA,CAAc,KAAK,OAA0B,CAAA;AAEvE;AAGO,SAAS,UAAU,KAA6B,EAAA;AACrD,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAE7B,IAAA,OAAO,GAAG,OAAQ,CAAA,gBAAA,CAAiB,IAAK,CAAA,SAAA,CAAU,KAAK,CAAC,CAAA;AAAA;AAE1D,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAA,MAAM,OACJ,GAAA,KAAA,GAAQ,CACJ,GAAA,EAAA,CAAG,OAAQ,CAAA,2BAAA;AAAA,MACT,GAAG,UAAW,CAAA,UAAA;AAAA,MACd,GAAG,OAAQ,CAAA,oBAAA,CAAqB,IAAK,CAAA,GAAA,CAAI,KAAK,CAAC;AAAA,KAEjD,GAAA,EAAA,CAAG,OAAQ,CAAA,oBAAA,CAAqB,KAAK,CAAA;AAC3C,IAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,qBAAA,CAAsB,OAAO,CAAA;AAAA;AAEjD,EAAI,IAAA,OAAO,UAAU,SAAW,EAAA;AAC9B,IAAO,OAAA,KAAA,KAAU,OAAO,IAAO,GAAA,KAAA;AAAA;AAEjC,EAAA,IAAI,UAAU,IAAM,EAAA;AAClB,IAAO,OAAA,IAAA;AAAA;AAET,EAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CAAG,EAAA;AACxB,IAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,MAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,KAAK,CAAA;AAAA;AAE7C,IAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,KAAM,CAAA,GAAA,CAAI,CAAC,CAAe,KAAA,SAAA,CAAU,CAAC,CAAC,CAAC,CAAA;AAAA;AAE/E,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAA,MAAM,OAAyB,EAAC;AAChC,IAAA,KAAA,MAAW,CAAC,CAAG,EAAA,CAAC,KAAK,MAAO,CAAA,OAAA,CAAQ,KAAK,CAAG,EAAA;AAC1C,MAAK,IAAA,CAAA,IAAA;AAAA,QACH,GAAG,OAAQ,CAAA,uBAAA;AAAA;AAAA,UACW,MAAA;AAAA;AAAA,UACA,gBAAgB,CAAC,CAAA;AAAA;AAAA,UACjB,MAAA;AAAA;AAAA,UACA,UAAU,CAAC;AAAA;AACjC,OACF;AAAA;AAEF,IAAO,OAAA,IAAA,CAAK,SAAS,EAAG,CAAA,OAAA,CAAQ,sBAAsB,IAAI,CAAA,GAAI,QAAS,CAAA,MAAA,EAAQ,KAAK,CAAA;AAAA;AAEtF,EAAO,OAAA,OAAA;AACT;AAGO,SAAS,YAAY,SAGV,EAAA;AAChB,EAAA,MAAM,WAA0B,EAAC;AACjC,EAAA,IAAI,UAAU,MAAQ,EAAA;AACpB,IAAA,QAAA,CAAS,KAAK,EAAG,CAAA,OAAA,CAAQ,eAAe,EAAG,CAAA,UAAA,CAAW,aAAa,CAAC,CAAA;AAAA;AAEtE,EAAA,IAAI,UAAU,QAAU,EAAA;AACtB,IAAA,QAAA,CAAS,KAAK,EAAG,CAAA,OAAA,CAAQ,eAAe,EAAG,CAAA,UAAA,CAAW,eAAe,CAAC,CAAA;AAAA;AAExE,EAAO,OAAA,QAAA;AACT;AAGO,SAAS,WAAW,KAAmC,EAAA;AAC5D,EAAA,OAAO,GAAG,OAAQ,CAAA,mBAAA,CAAoB,CAAC,GAAG,KAAA,EAAO,IAAI,CAAC,CAAA;AACxD;AAGgB,SAAA,MAAA,CAAO,MAAmB,IAA6B,EAAA;AACrE,EAAA,OAAO,GAAG,OAAQ,CAAA,uBAAA,CAAwB,GAAG,OAAQ,CAAA,gBAAA,CAAiB,MAAM,CAAG,EAAA;AAAA,IAC7E,IAAA;AAAA,IACA,EAAA,CAAG,OAAQ,CAAA,mBAAA,CAAoB,IAAK,CAAA,GAAA,CAAI,CAAC,CAAM,KAAA,SAAA,CAAU,CAAC,CAAC,CAAC;AAAA,GAC7D,CAAA;AACH;AAGgB,SAAA,QAAA,CAAS,KAAkB,KAAoB,EAAA;AAC7D,EAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,uBAAA,CAAwB,EAAG,CAAA,OAAA,CAAQ,gBAAiB,CAAA,QAAQ,CAAG,EAAA,CAAC,GAAK,EAAA,KAAK,CAAC,CAAA;AAC/F;AAGO,SAAS,gBAAgB,KAAwB,EAAA;AACtD,EAAA,IACG,OAAO,KAAU,KAAA,QAAA,IAAY,EAAE,KAAQ,GAAA,CAAA,CAAA,IACvC,OAAO,KAAU,KAAA,QAAA,IAAY,MAAO,CAAA,MAAA,CAAO,KAAK,CAAC,CAAA,KAAM,SAAS,KAAM,CAAA,CAAC,MAAM,GAC9E,EAAA;AACA,IAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,oBAAA,CAAqB,KAAK,CAAA;AAAA;AAE9C,EAAA,OAAO,OAAO,KAAU,KAAA,QAAA,IAAY,oBAAqB,CAAA,IAAA,CAAK,KAAK,CAC/D,GAAA,EAAA,CAAG,OAAQ,CAAA,gBAAA,CAAiB,KAAK,CACjC,GAAA,EAAA,CAAG,QAAQ,mBAAoB,CAAA,MAAA,CAAO,KAAK,CAAC,CAAA;AAClD;AAGO,SAAS,QAAQ,KAAmC,EAAA;AACzD,EAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,IAAO,OAAA,KAAA;AAAA;AAET,EAAI,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACtB,IAAA,OAAO,MAAM,CAAC,CAAA;AAAA;AAEhB,EAAA,OAAO,EAAG,CAAA,OAAA,CAAQ,mBAAoB,CAAA,QAAA,CAAS,KAAK,CAAC,CAAA;AACvD;AAGgB,SAAA,cAAA,CACd,IACA,EAAA,IAAA,EACA,YACa,EAAA;AACb,EAAI,IAAA,IAAA,CAAK,WAAW,CAAG,EAAA;AACrB,IAAO,OAAA,IAAA;AAAA;AAIT,EAAA,IAAI,CAAC,YAAA,CAAa,IAAK,CAAA,CAAC,IAAS,KAAA,EAAA,CAAG,sBAAuB,CAAA,IAAI,CAAK,IAAA,IAAA,EAAM,IAAM,EAAA,WAAA,KAAgB,cAAc,CAAG,EAAA;AAC/G,IAAA,MAAM,MAAS,GAAA,WAAA,CAAY,qEAAqE,CAAA,CAAE,CAAC,CAAA;AACnG,IAAA,YAAA,CAAa,KAAK,MAAM,CAAA;AAAA;AAG1B,EAAA,OAAO,GAAG,OAAQ,CAAA,uBAAA,CAAwB,GAAG,OAAQ,CAAA,gBAAA,CAAiB,cAAc,CAAG,EAAA;AAAA,IACrF,IAAA;AAAA,IACA,OAAA,CAAQ,KAAK,GAAI,CAAA,CAAC,MAAM,SAAU,CAAA,CAAC,CAAC,CAAC;AAAA,GACtC,CAAA;AACH;AAOgB,SAAA,eAAA,CAAgB,MAAmB,YAAuC,EAAA;AACxF,EAAA,IACE,YACA,IAAA,CAAC,YAAa,CAAA,IAAA,CAAK,CAAC,IAAS,KAAA,EAAA,CAAG,sBAAuB,CAAA,IAAI,CAAK,IAAA,IAAA,EAAM,IAAM,EAAA,WAAA,KAAgB,eAAe,CAC3G,EAAA;AACA,IAAA,MAAM,MAAS,GAAA,WAAA;AAAA,MACb;AAAA,MACA,CAAC,CAAA;AACH,IAAA,YAAA,CAAa,KAAK,MAAM,CAAA;AAAA;AAE1B,EAAO,OAAA,EAAA,CAAG,OAAQ,CAAA,uBAAA,CAAwB,EAAG,CAAA,OAAA,CAAQ,iBAAiB,eAAe,CAAA,EAAG,CAAC,IAAI,CAAC,CAAA;AAChG;;;;"}