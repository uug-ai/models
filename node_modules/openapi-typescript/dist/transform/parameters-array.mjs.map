{"version":3,"file":"parameters-array.mjs","sources":["../../src/transform/parameters-array.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { NEVER, QUESTION_TOKEN, addJSDocComment, oapiRef, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { ParameterObject, ReferenceObject, TransformNodeOptions } from \"../types.js\";\nimport transformParameterObject from \"./parameter-object.js\";\n\n// Regex to match path parameters in URL\nconst PATH_PARAM_RE = /\\{([^}]+)\\}/g;\n\n/**\n * Create a synthetic path parameter object from a parameter name\n */\nfunction createPathParameter(paramName: string): ParameterObject {\n  return {\n    name: paramName,\n    in: \"path\",\n    required: true,\n    schema: { type: \"string\" },\n  };\n}\n\n/**\n * Extract path parameters from a URL\n */\nfunction extractPathParamsFromUrl(path: string): ParameterObject[] {\n  const params: ParameterObject[] = [];\n  const matches = path.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      const paramName = match.slice(1, -1);\n      params.push(createPathParameter(paramName));\n    }\n  }\n  return params;\n}\n\n/**\n * Synthetic type. Array of (ParameterObject | ReferenceObject)s found in OperationObject and PathItemObject.\n */\nexport function transformParametersArray(\n  parametersArray: (ParameterObject | ReferenceObject)[],\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // Create a working copy of parameters array\n  const workingParameters = [...parametersArray];\n\n  // Generate path parameters if enabled\n  if (options.ctx.generatePathParams && options.path) {\n    const pathString = Array.isArray(options.path) ? options.path[0] : options.path;\n    if (typeof pathString === \"string\") {\n      const pathParams = extractPathParamsFromUrl(pathString);\n      // Only add path parameters that aren't already defined\n      for (const param of pathParams) {\n        const exists = workingParameters.some((p) => {\n          const resolved = \"$ref\" in p ? options.ctx.resolve<ParameterObject>(p.$ref) : p;\n          return resolved?.in === \"path\" && resolved?.name === param.name;\n        });\n        if (!exists) {\n          workingParameters.push(param);\n        }\n      }\n    }\n  }\n\n  // parameters\n  const paramType: ts.TypeElement[] = [];\n  for (const paramIn of [\"query\", \"header\", \"path\", \"cookie\"] as ParameterObject[\"in\"][]) {\n    const paramLocType: ts.TypeElement[] = [];\n    let operationParameters = workingParameters.map((param) => ({\n      original: param,\n      resolved: \"$ref\" in param ? options.ctx.resolve<ParameterObject>(param.$ref) : param,\n    }));\n\n    // this is the only array type in the spec, so we have to one-off sort here\n    if (options.ctx.alphabetize) {\n      operationParameters.sort((a, b) => (a.resolved?.name ?? \"\").localeCompare(b.resolved?.name ?? \"\"));\n    }\n    if (options.ctx.excludeDeprecated) {\n      operationParameters = operationParameters.filter(\n        ({ resolved }) => !resolved?.deprecated && !resolved?.schema?.deprecated,\n      );\n    }\n    for (const { original, resolved } of operationParameters) {\n      if (resolved?.in !== paramIn) {\n        continue;\n      }\n      let optional: ts.QuestionToken | undefined = undefined;\n      if (paramIn !== \"path\" && !(resolved as ParameterObject).required) {\n        optional = QUESTION_TOKEN;\n      }\n      const subType =\n        \"$ref\" in original\n          ? oapiRef(original.$ref, resolved)\n          : transformParameterObject(resolved as ParameterObject, {\n              ...options,\n              path: createRef([options.path, \"parameters\", resolved.in, resolved.name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(resolved?.name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(resolved, property);\n      paramLocType.push(property);\n    }\n    const allOptional = paramLocType.every((node) => !!node.questionToken);\n    paramType.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(paramIn),\n        /* questionToken */ allOptional || !paramLocType.length ? QUESTION_TOKEN : undefined,\n        /* type          */ paramLocType.length ? ts.factory.createTypeLiteralNode(paramLocType) : NEVER,\n      ),\n    );\n  }\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"parameters\"),\n      /* questionToken */ !paramType.length ? QUESTION_TOKEN : undefined,\n      /* type          */ paramType.length ? ts.factory.createTypeLiteralNode(paramType) : NEVER,\n    ),\n  );\n\n  return type;\n}\n"],"names":[],"mappings":"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"}