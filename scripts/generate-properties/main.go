// generate-properties parses Go model files and generates property constants
// based on the bson tags found in struct fields.
//
// Usage:
//
//	go run scripts/generate-properties/main.go           # Skip files with manual content
//	go run scripts/generate-properties/main.go --force   # Overwrite all files
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// StructProperties holds the extracted properties for a struct
type StructProperties struct {
	Name       string
	Properties []Property
}

// Property represents a single field's property constant
type Property struct {
	ConstName string
	BsonTag   string
}

var forceOverwrite bool

func main() {
	flag.BoolVar(&forceOverwrite, "force", false, "Overwrite files even if they have manual content")
	flag.Parse()

	modelsDir := "pkg/models"
	outputDir := "pkg/properties"

	// Find all Go files in models directory
	files, err := filepath.Glob(filepath.Join(modelsDir, "*.go"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding model files: %v\n", err)
		os.Exit(1)
	}

	// Group structs by source file
	fileStructs := make(map[string][]StructProperties)

	for _, file := range files {
		// Skip test files
		if strings.HasSuffix(file, "_test.go") {
			continue
		}

		structs, err := parseFile(file)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing %s: %v\n", file, err)
			continue
		}

		if len(structs) > 0 {
			baseName := filepath.Base(file)
			fileStructs[baseName] = structs
		}
	}

	// Generate property files
	for fileName, structs := range fileStructs {
		outputPath := filepath.Join(outputDir, fileName)

		// Check if file already exists with manual content
		if !forceOverwrite && fileHasManualContent(outputPath) {
			fmt.Printf("Skipping %s (has manual content, use --force to overwrite)\n", outputPath)
			continue
		}

		content := generatePropertyFile(structs)

		if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing %s: %v\n", outputPath, err)
			continue
		}

		fmt.Printf("Generated %s\n", outputPath)
	}
}

func parseFile(filename string) ([]StructProperties, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var structs []StructProperties

	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		structName := typeSpec.Name.Name
		props := extractProperties(structName, structType)

		if len(props.Properties) > 0 {
			structs = append(structs, props)
		}

		return true
	})

	return structs, nil
}

func extractProperties(structName string, structType *ast.StructType) StructProperties {
	props := StructProperties{
		Name: structName,
	}

	for _, field := range structType.Fields.List {
		if field.Tag == nil {
			continue
		}

		// Extract bson tag
		bsonTag := extractBsonTag(field.Tag.Value)
		if bsonTag == "" || bsonTag == "-" {
			continue
		}

		// Get field name
		if len(field.Names) == 0 {
			continue // embedded field
		}
		fieldName := field.Names[0].Name

		// Generate constant name
		constName := structName + fieldName

		props.Properties = append(props.Properties, Property{
			ConstName: constName,
			BsonTag:   bsonTag,
		})
	}

	return props
}

var bsonTagRegex = regexp.MustCompile(`bson:"([^,"]+)`)

func extractBsonTag(tagValue string) string {
	// Remove backticks
	tag := strings.Trim(tagValue, "`")

	matches := bsonTagRegex.FindStringSubmatch(tag)
	if len(matches) < 2 {
		return ""
	}

	return matches[1]
}

func generatePropertyFile(structs []StructProperties) string {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by generate-properties. DO NOT EDIT.\n")
	buf.WriteString("// Source: pkg/models/*.go\n\n")
	buf.WriteString("package properties\n\n")

	// Sort structs by name for consistent output
	sort.Slice(structs, func(i, j int) bool {
		return structs[i].Name < structs[j].Name
	})

	for i, s := range structs {
		if i > 0 {
			buf.WriteString("\n")
		}

		buf.WriteString(fmt.Sprintf("// %s property field names (BSON)\n", s.Name))
		buf.WriteString("const (\n")

		for _, p := range s.Properties {
			buf.WriteString(fmt.Sprintf("\t%s = %q\n", p.ConstName, p.BsonTag))
		}

		buf.WriteString(")\n")
	}

	return buf.String()
}

func fileHasManualContent(path string) bool {
	content, err := os.ReadFile(path)
	if err != nil {
		return false // file doesn't exist
	}

	// Check if file has the generated header
	return !strings.Contains(string(content), "Code generated by generate-properties")
}
